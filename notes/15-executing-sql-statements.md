Go provides three different methods for executing database queries:

- `DB.Query()` is used for `SELECT` queries which return multiple rows.
- `DB.QueryRow()` is used for `SELECT` queries which return a single row.
- `DB.Exec()` is used for statements which don't return rows (like `INSERT` and `DELETE`).

### DB.Exec() function

It returns `sql.Result` type which provides two methods:

- `LastInsertId()` - which returns the integer (an int64) generated by the database in response to a command.

- `RowsAffected()` - which returns the number of rows (an int64) affected by the statement.

### Placeholder parameters

The reason for using placeholder parameters (`?`) is to help avoid SQL injection attacks from any untrusted user-provided input.

Behine the scenes, the `DB.Exec()` method works in three steps:

1. It creates a new prepared statement on the database using the provided SQL statement. The database parses and compiles the statement, then stores it ready for execution.

2. In a second step, `DB.Exec()` passes the parameter values to the database. The database then executes the prepared statement using these parameters. Because the parameters are transmitted later, after the statement has been compiled, the database treats them as pure data. They can't change the intent of the statement. So long as the original statement is not derived from untrusted data, injection cannot occur.

3. It then closes (or deallocates) the prepared statement on the database.

### DB.Query() function

It returns a pointer to a `sql.Row` object which holds the result from the database. We can then call `row.Scan()` to copy the values from each field in sql.Row to the corresponding field in the Snippet struct.

Behind the scenes of `rows.Scan()` your driver automatically convert the raw output from the SQL database to the required native Go types -

- `CHAR`, `VARCHAR` and `TEXT` map to `string`.
- `BOOLEAN` maps to `bool`.
- `INT` maps to `int`; `BIGINT` maps to `int64`.
- `DECIMAL` and `NUMERIC` map to `float`.
- `TIME`, `DATE` and `TIMESTAMP` map to `time.Time`.

### DB.QueryRow() function

This returns a `sql.Rows` resultset containing the result of our query. We can then call `rows.Next()` and `rows.Scan()` methods to obtain all the rows:

```go
for rows.Next() {
    // Create a pointer to a new zeroed Snippet struct
    var s Snippet

    // Use rows.Scan() to copy the values from each field in the row to the
    // new Snippet object that we created. Again, the arguments to row.Scan()
    // must be pointers to the place you want to copy the data into, and the
    // number of arguments must be exactly the same as the number of
    // columns returned by your statement.
    err = rows.Scan(&s.ID, &s.Title, &s.Content, &s.Created, &s.Expires)
    if err != nil {
        return nil, err
    }

    // Append it to the slice of snippets.
    snippets = append(snippets, s)
}
```

Then we should call `rows.Close()`. As long as a resultset is open it will keep the underlying database connection open… so if something goes wrong in this method and the resultset isn’t closed, it can rapidly lead to all the connections in your pool being used up.
